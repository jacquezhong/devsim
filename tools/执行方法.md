# 学术论文生成执行方法

## 概述

本文档描述了从实验方案（workflow.md）到最终学术论文（{论文标题}.docx）的完整执行流程。该流程整合了多个技能模块，遵循学术规范，实现了从实验设计、数据收集、分析到论文撰写的自动化工作流。

**适用范围**: workspace/plan1 ~ workspace/plan4 及其他基于DEVSIM的研究方案

---

## 执行流程

### 第一阶段：实验准备与初始化

#### 1.1 读取实验方案
- **输入**: `workspace/{plan_name}/workflow.md` （如 plan1, plan2, plan3, plan4）
- **操作**: 解析实验目标、参数范围、预期结论
- **关键检查**:
  - 确认实验参数（具体参数因方案而异，见下方"方案能力映射"）
  - 验证仿真方法（根据workflow中的能力ID确定）
  - 明确预期结论和定量关系

#### 1.2 环境配置
- **Conda环境**: `devsim` 或 `base`
- **验证命令**:
  ```bash
  conda activate devsim 2>/dev/null || conda activate base
  python3 -c "import devsim; print(devsim.__version__)"
  ```
- **依赖安装**:
  ```bash
  pip install devsim numpy matplotlib
  ```

---

### 第二阶段：实验执行与数据收集

#### 2.1 调用仿真技能
- **技能名称**: `devsim-examples`
- **路径**: `.opencode/skills/devsim-examples/`
- **可用能力ID**（根据方案选择）:
  - `diode_1d_dc_iv`: 一维二极管DC仿真
  - `diode_1d_transient`: 一维二极管瞬态仿真
  - `diode_2d_dc_iv`: 二维二极管DC仿真
  - `capacitance_2d_electrostatic`: 二维静电场/电容仿真
  - `bioapp_2d_ion_channel`: 离子通道生物应用仿真
- **调用方式**:
  ```python
  from devsim_examples import {capability_id}
  result = {capability_id}(**parameters)
  ```

#### 2.2 参数扫描
根据workflow.md中定义的研究参数进行扫描：
- **物理参数**: 载流子寿命、掺杂浓度、介电常数、离子浓度等
- **几何参数**: 器件长度、线间距、通道直径等
- **电学参数**: 偏置电压、扫描范围、时间步长等
- **扫描原则**: 在合理范围内选取5-7个代表值，覆盖线性/对数尺度
- **数据清理**: 每次仿真前清理mesh
  ```python
  devsim.delete_device(device="device_name")
  devsim.delete_mesh(mesh="mesh_name")
  ```

#### 2.3 数据提取
- **电流/电压提取**: 使用 `devsim.get_contact_current()`, `devsim.get_contact_voltage()`
- **场分布提取**: 使用 `devsim.get_edge_model_values()`, `devsim.get_node_model_values()`
- **性能参数计算**: 根据研究目标定义（如导通电阻、击穿电压、电容矩阵等）

---

### 第三阶段：数据分析与可视化

#### 3.1 图表生成规范
- **工具**: Matplotlib
- **字体设置**: `Hiragino Sans GB` (macOS)
- **图表要求**:
  - 图片本身**不包含标题**（标题在正文中）
  - 保留子图标签: (a), (b), (c), (d)
  - 坐标轴标签完整，包含单位
  - 分辨率: 300 DPI
  - 格式: PNG

#### 3.2 图表编号规则
图表编号按论文逻辑顺序排列：
- **图1**: 器件结构示意图或基准特性曲线
- **图2-N**: 参数扫描结果（按参数类型分组）
- **图N+1**: Pareto前沿或权衡分析（如适用）
- **说明**: 示意图用文字描述替代，不单独成图

#### 3.3 图表优化
- **避免重叠**: 调整标注位置（左右交替）
- **清晰可读**: 添加背景框，增大对比度
- **颜色编码**: 使用viridis色谱，红蓝对比

---

### 第四阶段：论文撰写

#### 4.1 论文结构（遵循paper-writing技能）
```
标题
├── 摘要 (Abstract)
│   ├── 研究背景
│   ├── 方法
│   ├── 主要结果
│   └── 结论
├── 1. 引言 (Introduction)
│   ├── 1.1 研究背景
│   ├── 1.2 影响因素
│   ├── 1.3 研究现状
│   └── 1.4 本文贡献
├── 2. 仿真模型与方法 (Methodology)
│   ├── 2.1 仿真平台
│   ├── 2.2 器件结构
│   ├── 2.3 参数扫描
│   └── 2.4 参数提取
├── 3. 结果与讨论 (Results & Discussion)
│   ├── 3.1 参数A影响分析
│   ├── 3.2 参数B影响分析
│   ├── 3.3 权衡分析与优化
│   └── 3.4 文献对比与验证
├── 4. 结论 (Conclusion)
├── 5. 展望 (Future Work)
└── 参考文献 (References)
```

#### 4.2 学术规范
- **引用格式**: GB/T 7714-2015（中文期刊标准）
- **公式编号**: 使用 $$...$$ 环境
- **图表引用**: "图1展示了..."、"表1给出了..."
- **单位**: 使用国际标准单位（cm⁻³, s, V, Ω·cm²）

#### 4.3 参考文献标准
- **学术期刊**: >80% 引用来自SCI/EI期刊
- **会议论文**: 顶级会议（如ISPSD）优先
- **教材**: 经典教材（如Sze《半导体器件物理》）
- **禁止**: 网页、博客、非学术来源

---

### 第五阶段：文档生成（直接生成 DOCX）

**原则**: 不使用 Markdown 中转，直接用 `python-docx` 从数据生成 Word 文档，确保公式、下标正确显示。

#### 5.1 技术方案

**方案A：简单下标/上标（推荐）**
- 使用 `run.font.subscript = True` 实现下标
- 适合：`N_A`, `τ_n`, `Q_rr`, `V_bi`, `E_c` 等常见半导体符号
- 优点：轻量、可编辑、无需外部依赖

**方案B：复杂公式图片化**
- 用 matplotlib 将 LaTeX 公式渲染为 PNG 插入
- 适合：复杂积分、矩阵、分式等
- 优点：显示完美，与 LaTeX 效果一致

#### 5.2 技术方案推荐（XSLT 方法）

**方案C：XSLT 转换法（最佳实践，推荐）**

使用 Microsoft Office 官方 XSLT 样式表将 MathML 转换为 OMML，生成真正可编辑的 Word 公式。

**依赖**：
- `lxml`（XML 处理）
- `latex2mathml`（LaTeX → MathML）
- `tools/MML2OMML.XSL`（Microsoft 官方转换表）

**安装**：
```bash
pip install lxml latex2mathml
```

**核心代码**：
```python
import sys
sys.path.insert(0, '/path/to/devsim/tools')

import lxml.etree as etree
from docx import Document
from docx.oxml import parse_xml
import latex2mathml.converter

# 加载 XSLT 转换器
XSLT_PATH = '/path/to/devsim/tools/MML2OMML.XSL'
xslt = etree.XSLT(etree.parse(XSLT_PATH))

def clean_latex(latex_str):
    """清理 LaTeX，去除歧义空格，确保 {} 包裹"""
    latex = latex_str.strip()
    
    # 移除行内公式标记
    if latex.startswith('$') and latex.endswith('$'):
        latex = latex[1:-1]
    
    # 处理多字母下标：Q_rr -> Q_{rr}
    import re
    latex = re.sub(r'([a-zA-Z])_([a-zA-Z0-9]+)(?![\{])', r'\1_{\2}', latex)
    
    # 处理上标：10^-8 -> 10^{-8}
    latex = re.sub(r'([a-zA-Z0-9])\^([a-zA-Z0-9\-]+)(?![\{])', r'\1^{\2}', latex)
    
    # 规范化特殊符号
    latex = latex.replace('~', '\\sim ')
    latex = latex.replace('×', '\\times ')
    
    return latex

def add_formula(paragraph, latex_str, display_mode=True):
    """使用 XSLT 方法插入公式"""
    try:
        # 1. 清理 LaTeX
        clean_latex_str = clean_latex(latex_str)
        
        # 2. LaTeX -> MathML
        mathml = latex2mathml.converter.convert(clean_latex_str)
        
        # 3. MathML -> OMML (使用 XSLT)
        omml_tree = xslt(etree.fromstring(mathml.encode('utf-8')))
        
        # 4. 转换为字符串并添加命名空间
        omml_str = etree.tostring(omml_tree, encoding='unicode', with_tail=False)
        if '?>' in omml_str:
            omml_str = omml_str.split('?>')[-1].strip()
        
        m_ns = 'xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"'
        if 'xmlns:m=' not in omml_str:
            omml_str = omml_str.replace('<m:oMath', f'<m:oMath {m_ns}', 1)
        
        # 5. 插入文档
        if display_mode:
            paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        paragraph._element.append(parse_xml(omml_str))
        return True
        
    except Exception as e:
        print(f"公式转换失败: {e}")
        paragraph.add_run(f"[公式: {latex_str[:30]}...]")
        return False
```

**关键要点**：
1. **LaTeX 清理**：必须先清理歧义空格，确保所有下标/上标都有 `{}`
2. **XSLT 路径**：必须使用 `tools/MML2OMML.XSL` 文件
3. **命名空间**：必须添加 `xmlns:m` 命名空间，否则 Word 无法识别
4. **多字母下标**：正则 `([a-zA-Z])_([a-zA-Z0-9]+)` 匹配 `Q_rr` 而非 `Q_r`

#### 5.3 完整代码示例

```python
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
import re
import os
import sys

# 添加 tools 目录到路径
sys.path.insert(0, '/path/to/devsim/tools')

import lxml.etree as etree
from docx.oxml import parse_xml
import latex2mathml.converter

# 初始化 XSLT
XSLT_PATH = '/path/to/devsim/tools/MML2OMML.XSL'
xslt = etree.XSLT(etree.parse(XSLT_PATH))

def clean_latex(latex_str):
    """清理 LaTeX 公式"""
    latex = latex_str.strip()
    if latex.startswith('$') and latex.endswith('$'):
        latex = latex[1:-1]
    
    # 处理多字符下标和上标
    latex = re.sub(r'([a-zA-Z])_([a-zA-Z0-9]+)(?![\{])', r'\1_{\2}', latex)
    latex = re.sub(r'([a-zA-Z0-9])\^([a-zA-Z0-9\-]+)(?![\{])', r'\1^{\2}', latex)
    latex = latex.replace('~', '\\sim ').replace('×', '\\times ')
    
    return latex

def add_formula(paragraph, latex_str, display_mode=True):
    """插入公式到段落"""
    try:
        clean_latex_str = clean_latex(latex_str)
        mathml = latex2mathml.converter.convert(clean_latex_str)
        omml_tree = xslt(etree.fromstring(mathml.encode('utf-8')))
        omml_str = etree.tostring(omml_tree, encoding='unicode', with_tail=False)
        
        if '?>' in omml_str:
            omml_str = omml_str.split('?>')[-1].strip()
        
        m_ns = 'xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"'
        if 'xmlns:m=' not in omml_str:
            omml_str = omml_str.replace('<m:oMath', f'<m:oMath {m_ns}', 1)
        
        if display_mode:
            paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        paragraph._element.append(parse_xml(omml_str))
        return True
    except Exception as e:
        print(f"公式失败: {e}")
        paragraph.add_run(f"[{latex_str[:30]}...]")
        return False

def process_inline_text(paragraph, text):
    """处理行内文本，识别粗体和公式"""
    # 先分割粗体 **...**
    bold_parts = re.split(r'(\*\*[^*]+\*\*)', text)
    
    for bold_part in bold_parts:
        if bold_part.startswith('**') and bold_part.endswith('**') and len(bold_part) > 4:
            # 粗体
            run = paragraph.add_run(bold_part[2:-2])
            run.font.bold = True
            run.font.name = 'Times New Roman'
        else:
            # 分割行内公式 $...$
            formula_parts = re.split(r'(\$[^$]+\$)', bold_part)
            
            for part in formula_parts:
                if part.startswith('$') and part.endswith('$') and len(part) > 2:
                    # 行内公式
                    add_formula(paragraph, part[1:-1], display_mode=False)
                else:
                    # 普通文本（带下标处理）
                    if part.strip():
                        add_text_with_subscripts(paragraph, part)

def add_text_with_subscripts(paragraph, text):
    """添加带下标的文本"""
    # 下标模式映射
    subscripts = [
        ('Q_{rr}', 'Q', 'rr'), ('Q_rr', 'Q', 'rr'),
        ('t_{rr}', 't', 'rr'), ('t_rr', 't', 'rr'),
        ('V_{bi}', 'V', 'bi'), ('V_bi', 'V', 'bi'),
        ('R_{on}', 'R', 'on'), ('R_on', 'R', 'on'),
        ('N_A', 'N', 'A'), ('N_D', 'N', 'D'),
        ('J_F', 'J', 'F'), ('I_F', 'I', 'F'),
        ('τ_n', 'τ', 'n'), ('τ_p', 'τ', 'p'),
        ('n_i', 'n', 'i'), ('x_j', 'x', 'j'),
    ]
    
    i = 0
    while i < len(text):
        matched = False
        for pattern, base, sub in sorted(subscripts, key=lambda x: -len(x[0])):
            if i + len(pattern) <= len(text) and text[i:i+len(pattern)] == pattern:
                run = paragraph.add_run(base)
                run.font.italic = True
                run.font.name = 'Times New Roman'
                run = paragraph.add_run(sub)
                run.font.subscript = True
                run.font.size = Pt(9)
                run.font.name = 'Times New Roman'
                i += len(pattern)
                matched = True
                break
        
        if not matched:
            run = paragraph.add_run(text[i])
            run.font.name = 'Times New Roman'
            i += 1

def create_docx():
    """生成论文文档"""
    doc = Document()
    
    # 设置字体
    style = doc.styles['Normal']
    style.font.name = 'Times New Roman'
    style._element.rPr.rFonts.set(qn('w:eastAsia'), 'SimSun')
    style.font.size = Pt(10.5)
    
    # 标题
    title = doc.add_heading('论文标题', level=0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER
    for run in title.runs:
        run.font.name = 'SimHei'
        run._element.rPr.rFonts.set(qn('w:eastAsia'), 'SimHei')
        run.font.size = Pt(16)
        run.font.bold = True
    
    # 行间公式示例
    doc.add_paragraph()
    para = doc.add_paragraph()
    add_formula(para, r'Q_{rr} = \tau \cdot J_F')
    doc.add_paragraph()
    
    # 保存
    doc.save('论文.docx')

if __name__ == '__main__':
    create_docx()
```

#### 5.3 格式规范

| 元素 | 字体 | 字号 | 格式 |
|------|------|------|------|
| 正文 | Times New Roman + 宋体 | 10.5pt | 首行缩进0.5英寸 |
| 一级标题 | 黑体 | 16pt | 居中 |
| 二级标题 | 黑体 | 14pt | 左对齐 |
| 三级标题 | 黑体 | 12pt | 左对齐 |
| 图注 | 宋体 | 9pt | 居中 |
| 下标 | Times New Roman | 9pt | subscript |

#### 5.4 文件命名
- **Word文档**: `{论文标题}.docx` （直接生成，无需Markdown中转）
- **数据**: `data/final/*.json`
- **图表**: `figures/final/*.png`
- **脚本**: `generate_docx.py`

---

## 使用的技能与工具

### 核心技能

#### 1. devsim-examples（仿真技能）
- **位置**: `.opencode/skills/devsim-examples/`
- **功能**: TCAD器件仿真
- **方案能力映射**:
  | 方案 | 研究主题 | 主要能力ID | 辅助能力 |
  |------|---------|-----------|---------|
  | plan1 | 功率二极管反向恢复 | `diode_1d_dc_iv`, `diode_1d_transient` | - |
  | plan2 | 互连线寄生电容 | `capacitance_2d_electrostatic` | Gmsh网格 |
  | plan3 | 离子通道传感器 | `bioapp_2d_ion_channel` | - |
  | plan4 | 场板结构二极管 | `diode_2d_dc_iv` | Gmsh网格 |
- **调用方式**:
  ```python
  from devsim_examples import {capability_id}
  result = {capability_id}(**parameters)
  ```
- **输出**: 根据能力不同，输出IV曲线、电容矩阵、离子电流等

#### 2. paper-writing（写作技能）
- **位置**: `.opencode/skills/paper-writing/`
- **功能**: 学术论文结构指导
- **规范**:
  - IMRaD结构（Introduction, Methodology, Results, Discussion）
  - 摘要写作4要素（背景、方法、结果、结论）
  - 图表规范

### 辅助工具

#### 3. Matplotlib（可视化）
- **用途**: 生成学术级图表
- **配置**:
  ```python
  plt.rcParams['font.sans-serif'] = ['Hiragino Sans GB']
  plt.rcParams['axes.unicode_minus'] = False
  ```

#### 4. python-docx（文档生成）
- **用途**: 生成Word文档
- **安装**: `pip install python-docx`

---

## 关键规范与注意事项

### 图表规范
1. **图片无标题原则**: 所有图表标题必须在正文中，不在matplotlib中设置
2. **子图标签**: 使用(a), (b), (c), (d)标注子图位置
3. **数据标注**: 避免与曲线重叠，使用交替布局

### 数据管理
1. **版本控制**: 所有实验数据、代码、文档纳入Git管理
2. **数据备份**: JSON格式保存原始数据，便于复现
3. **图表归档**: PNG格式（300 DPI），命名规范：`fig{N}_{description}.png`

### 学术诚信
1. **引用真实性**: 所有参考文献必须真实可查
2. **数据来源**: 仿真参数、结果必须可追溯
3. **结论客观**: 基于数据的定量结论，避免主观臆断

---

## 执行脚本示例

### 主执行脚本
```python
#!/usr/bin/env python3
# main_workflow.py

import subprocess
import sys
import os

def main():
    plan_name = "plan1"  # 修改为当前方案名称
    workspace_dir = f"workspace/{plan_name}"
    
    # Step 1: 运行实验
    subprocess.run([sys.executable, f"{workspace_dir}/experiment.py"])
    
    # Step 2: 生成图表
    subprocess.run([sys.executable, f"{workspace_dir}/generate_figures.py"])
    
    # Step 3: 生成Word文档
    subprocess.run([sys.executable, f"{workspace_dir}/generate_docx.py"])
    
    print(f"✅ {plan_name} 工作流完成！")

if __name__ == '__main__':
    main()
```

---

## 目录结构规范

```
workspace/{plan_name}/              # 如 plan1, plan2, plan3, plan4
├── workflow.md                    # 实验方案（必须）
├── {论文标题}.docx                 # 最终Word文档（直接生成）
├── data/
│   └── final/
│       ├── param1_results.json    # 参数1扫描数据
│       ├── param2_results.json    # 参数2扫描数据
│       └── ...
├── figures/
│   └── final/
│       ├── fig1_*.png             # 图表1
│       ├── fig2_*.png             # 图表2
│       └── ...
├── experiment.py                  # 主实验脚本
├── generate_figures.py            # 图表生成脚本
└── generate_docx.py               # Word生成脚本（直接生成docx）
```

**注意**: 不再使用 Markdown 中转，所有文本内容直接在 `generate_docx.py` 中定义。

---

## 常见问题与解决方案

### Q1: 图片中文字显示为方框
**原因**: 缺少中文字体
**解决**: 设置matplotlib字体为'Hiragino Sans GB'或'SimHei'

### Q2: 公式中的下标显示不正确
**原因**: 直接写 `N_A` 会被当作普通文本
**解决**: 
```python
run = para.add_run('N')
run = para.add_run('A')
run.font.subscript = True  # 设置下标
```

### Q3: 复杂公式无法编辑
**原因**: 使用图片方式插入公式
**解决**: 
- 简单公式：使用下标/上标（可编辑）
- 复杂公式：接受图片方式，或在Word中手动编辑
- 如需可编辑公式，考虑使用 `docx-omml` 库（较复杂）

### Q4: 图表标注被线条盖住
**原因**: 默认标注位置在数据点附近
**解决**: 手动调整xytext偏移量，使用交替布局

### Q5: 图片标题重复（图中+文中）
**原因**: matplotlib设置了标题，正文中又写了一遍
**解决**: 去掉matplotlib中的set_title()，只在正文中写标题

### Q6: 如何批量添加带下标的符号
**解决**: 封装辅助函数
```python
def add_symbol(para, base, subscript=None, superscript=None, italic=True):
    """添加带上下标的符号，如 N_A, V_bi, E_c 等"""
    run = para.add_run(base)
    if italic:
        run.font.italic = True
    if subscript:
        run = para.add_run(subscript)
        run.font.subscript = True
        run.font.size = Pt(9)
    if superscript:
        run = para.add_run(superscript)
        run.font.superscript = True
        run.font.size = Pt(9)

# 使用示例
para = doc.add_paragraph()
add_symbol(para, 'N', 'A')      # N_A
add_symbol(para, 'τ', 'n')      # τ_n
add_symbol(para, 'E', 'c')      # E_c
```

---

## 扩展与定制

### 添加新的参数扫描
1. 修改 `experiment.py` 中的参数列表（参考workflow.md中的参数范围）
2. 在 `data/final/` 中保存新的JSON结果
3. 添加对应的可视化脚本
4. 在 `generate_docx.py` 中增加结果讨论章节（直接写Word）

### 更换图表样式
1. 修改 `generate_figures.py` 中的matplotlib配置
2. 调整颜色、字体、布局参数
3. 重新运行生成脚本

### 适配不同期刊格式
1. 修改 `generate_docx.py` 中的格式设置
2. 调整字体、行距、页边距
3. 更改引用格式（GB/T 7714, APA, IEEE等）

### 迁移到新方案（plan2/plan3/plan4）
1. 读取对应方案的 `workspace/{plan_name}/workflow.md`
2. 根据"方案能力映射"表选择正确的能力ID
3. 调整参数列表（参考新workflow的参数定义）
4. 修改数据提取和可视化逻辑（不同能力输出不同）
5. 在 `generate_docx.py` 中重新组织论文结构（直接写Word，无Markdown中转）
6. 保持目录结构和文件命名规范一致

---

## 版本历史

- **v1.0** (2026-02-16): 初始版本，完成从workflow到docx的完整流程
- **v1.1** (2026-02-16): 移除Markdown中转，改为直接生成DOCX，解决公式显示问题

---

## 参考文献

1. DEVSIM Documentation: https://devsim.org/
2. Matplotlib Documentation: https://matplotlib.org/
3. python-docx Documentation: https://python-docx.readthedocs.io/
4. GB/T 7714-2015 信息与文献 参考文献著录规则
